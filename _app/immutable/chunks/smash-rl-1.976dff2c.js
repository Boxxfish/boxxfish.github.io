import{S as Vr,i as Kr,s as Xr,k as i,q as l,a as p,l as o,m as s,r as h,h as t,c as u,n as f,Q as _s,b as n,E as a,K as As}from"./index.d68af908.js";function Zr(Jr){let b,Za,Wt,de,$a,Ot,k,E,Re,ei,qt,me,ti,Ct,ge,ai,Ht,ye,ii,Gt,I,Ps,Rt,ve,oi,Ut,we,si,zt,be,ri,Yt,ke,ni,Jt,_,li,Ue,hi,fi,Vt,A,pi,ze,ui,ci,Kt,P,x,Ye,di,Xt,Ee,mi,Zt,c,Ie,Je,gi,yi,vi,_e,Ve,wi,bi,ki,Ae,Ke,Ei,Ii,_i,Pe,Xe,Ai,Pi,xi,xe,Ze,Si,Li,$t,m,Ni,$e,Ti,Di,he,ji,Bi,ea,S,L,et,Qi,ta,Se,Mi,aa,Le,Fi,ia,N,tt,Wi,Oi,at,qi,oa,T,D,it,Ci,sa,Ne,ot,Hi,ra,j,B,st,Gi,na,Q,rt,Ri,Ui,nt,zi,la,M,F,lt,Yi,ha,W,Ji,ht,Vi,Ki,fa,g,ft,Xi,Zi,pt,$i,eo,ut,to,pa,O,q,ct,ao,ua,C,dt,io,oo,mt,so,ca,H,G,gt,ro,da,Te,yt,no,ma,R,U,vt,lo,ga,De,ho,ya,y,wt,fo,po,bt,uo,co,kt,mo,va,z,Y,Et,go,wa,v,It,yo,vo,_t,wo,bo,At,ko,ba,J,V,Pt,Eo,ka,je,xt,Io,Ea,K,X,St,_o,Ia,Be,Ao,_a,Z,Po,Lt,xo,So,Aa,Qe,Lo,Pa,d,Nt,No,To,Tt,Do,jo,Dt,Bo,Qo,jt,Mo,xa,Me,Fo,Sa,$,Wo,Bt,Oo,qo,La,ee,Co,fe,Ho,Go,Na,Fe,Ro,Ta,We,Uo,Da,Oe,zo,ja,te,xs,Ba,ae,Yo,pe,Jo,Vo,Qa,ie,Ss,Ma,oe,se,Qt,Ko,Fa,re,Xo,Mt,Zo,$o,Wa,ne,es,Ft,ts,as,Oa,ue,is,ce,os;return{c(){b=i("p"),Za=l("One of the coolest applications of machine learning to me is using it to learn to play video games. It’s what got me interested in reinforcement learning in the first place. There’s nothing quite like watching an algorithm slowly go from pressing random buttons, to having almost complete mastery of a game, to the point where it sometimes it’ll do things that surprise even you."),Wt=p(),de=i("p"),$a=l("I’ve been spending some time on the side trying to train an agent to play Smash Bros. In this post, I’ll share what my approach was, and also highlight some of the prior work that’s been done here."),Ot=p(),k=i("h2"),E=i("a"),Re=i("span"),ei=l("But Why Smash?"),qt=p(),me=i("p"),ti=l("For the uninitiated, Super Smash Bros. is a fighting game series where two players attempt to knock each other off of a shared platform. Each character is equipped with a variety of moves to inflict damage (measured as a percentage from 0% to 999%) and send the opponent flying. The more damage a fighter, the harder they fly back."),Ct=p(),ge=i("p"),ai=l("Its large roster of iconic video game characters (where else can you watch Mario beat up Pacman?), alongside its easy to learn yet difficult to master gameplay, has made it one of Nintendo’s bestsellers. The latest game contains 82 different characters, all with their own moveset and properties."),Ht=p(),ye=i("p"),ii=l("For instance, Pikachu is a small, nimble fighter who has a variety of fast attacks, but can be easily launched from the stage even at low percentages due to its light body weight. Donkey Kong, on the other hand, is a powerful, heavy fighter with good horizontal recovery, but has a large hitbox and struggles to recover vertically."),Gt=p(),I=i("img"),Rt=p(),ve=i("p"),oi=l("Despite each fighter’s unique qualities, they all obey a common set of rules."),Ut=p(),we=i("p"),si=l("All characters have a set of standard attacks that can be executed on the ground (ground attacks) and in the air (aerial attacks) by pressing the “A” button and holding down a direction. If a direction is pressed at the same time the “A” button is pressed, the player can charge up a “smash” attack that deals heavy damage and sends the opponent flying. Each fighter is also equipped with four special moves that can be used by pressing the “B” button and a direction."),zt=p(),be=i("p"),ri=l("For defense, holding down the shield button causes a protective shield to appear around the character, which shrinks with more hits and time. While standard and special attacks can’t penetrate through the shield, this leaves the character open to being grabbed."),Yt=p(),ke=i("p"),ni=l("Aside from being fun to play, it’s also an interesting problem for AI! An agent capable of beating top players can’t just master the basic rules of the game, but also know how every character should fight against every other character. In one match up, the best strategy might be to keep the opponent away by shooting at them, then running away when they get too close. In another, it might be best to get up close and unleash a flurry of attacks, forcing the other player to make mistakes."),Jt=p(),_=i("p"),li=l(`To best make these decisions, the agent has to take a lot of variables into account: the positions of each player, which state each fighter is in (shielding? recovering? charging up a smash attack?), unique characteristics of the fighter (weight, jump height), how damaged they are, etc.
Even if an agent `),Ue=i("em"),hi=l("did"),fi=l(" get really good at all of this, it’d still have to master the psychological aspect of the game, trying to get inside its opponent’s head while avoiding the same from happening to it."),Vt=p(),A=i("p"),pi=l(`While there are 5 games in the Smash series, we’ll be focusing on Super Smash Bros. Melee, the game with the most active competitive scene.
Because it’s so widely played, the community has made it really easy to get it up and running on a PC, which makes training `),ze=i("em"),ui=l("way"),ci=l(" easier."),Kt=p(),P=i("h2"),x=i("a"),Ye=i("span"),di=l("Prior Work"),Xt=p(),Ee=i("p"),mi=l(`A couple people have already experimented with using deep learning to train an agent to play Melee.
Here’s a selection of work I was able to dig up:`),Zt=p(),c=i("ul"),Ie=i("li"),Je=i("strong"),gi=l("“Beating the World’s Best at Super Smash Bros. Melee with Deep Reinforcement Learning” (2017)"),yi=l(", a paper by Vlad Firoiu, William F. Whitney, and Josh Tenenbaum,"),vi=p(),_e=i("li"),Ve=i("strong"),wi=l("“Learning to Play Super Smash Bros. Melee with Delayed Actions” (2017)"),bi=l(", a paper by Yash Sharma and Eli Friedman,"),ki=p(),Ae=i("li"),Ke=i("strong"),Ei=l("“At Human Speed: Deep Reinforcement Learning with Action Delay” (2018)"),Ii=l(", a paper by Vlad Firoiu, Tina Ju, and Josh Tenenbaum,"),_i=p(),Pe=i("li"),Xe=i("strong"),Ai=l("“Project Nabla” (2022)"),Pi=l(", a blog post by Brian Chen, and"),xi=p(),xe=i("li"),Ze=i("strong"),Si=l("“AI Learns to Play Super Smash Bros” (2022)"),Li=l(", a video by the Youtuber AI Spawn."),$t=p(),m=i("p"),Ni=l(`I’ve broken these down by technique below.
I’ll be giving `),$e=i("em"),Ti=l("super"),Di=l(" oversimplified explanations of how each reinforcement learning algorithm works; if you want to learn more, "),he=i("a"),ji=l("this"),Bi=l(" is one of the most intuitive sources I’ve found for beginners."),ea=p(),S=i("h3"),L=i("a"),et=i("span"),Qi=l("Behavior Cloning"),ta=p(),Se=i("p"),Mi=l("At the most basic, we have behavior cloning. These approaches take recordings of real players and train a network to replicate them."),aa=p(),Le=i("p"),Fi=l(`The dataset will typically contain the state of the game as input, and a one hot encoded vector corresponding to the correct action as the output.
Once the network’s trained, you pass data from the game to the network, and take the maximum value of the network.`),ia=p(),N=i("ul"),tt=i("li"),Wi=l("Project Nabla pretrains a network with scalar features to output one hot encoded actions. The network uses a recurrent GRU layers to take past frames into account."),Oi=p(),at=i("li"),qi=l("The AI Spawn video used a collection of publically available replays and trained an MLP on it."),oa=p(),T=i("h4"),D=i("a"),it=i("span"),Ci=l("Pros:"),sa=p(),Ne=i("ul"),ot=i("li"),Hi=l("Easy to understand and implement."),ra=p(),j=i("h4"),B=i("a"),st=i("span"),Gi=l("Cons:"),na=p(),Q=i("ul"),rt=i("li"),Ri=l("Doesn’t generalize well to unseen game states."),Ui=p(),nt=i("li"),zi=l("You need an expert to record a bunch of games for you."),la=p(),M=i("h3"),F=i("a"),lt=i("span"),Yi=l("Deep Q Networks (DQNs)"),ha=p(),W=i("p"),Ji=l(`Next, we have Deep Q Networks.
This is the first algorithm where the AI learns by actually playing the game.
Because there no longer is a “right answer” for each game state, we have to define a reward function for the game, like +1 if you knock the other player off, and -1 if you get knocked off instead.
With Deep Q Networks, you train a network to associate each state with the reward it `),ht=i("em"),Vi=l("thinks"),Ki=l(` it’ll get in the next state, and so on.
Eventually, you get to a point where you can accurately predict how much reward you’ll get at any given game state, which means like with behavior cloning, you can just choose the action that outputs the max value.`),fa=p(),g=i("ul"),ft=i("li"),Xi=l("Firouiu (2017) trained DQNs both against the in-game AI and through self play, finding that Q networks could easily exploit edge cases in the opponent. They used an MLP where each player’s position, velocity, action state, etc were passed."),Zi=p(),pt=i("li"),$i=l("Sharma trained a DQN with a recurrent architecture against the in-game AI to allow it to use information seen in previous frames."),eo=p(),ut=i("li"),to=l("AI Spawn trained a DQN against the in-game AI, also finding that Q networks tend to take advantage of bugs in the in-game AI."),pa=p(),O=i("h4"),q=i("a"),ct=i("span"),ao=l("Pros:"),ua=p(),C=i("ul"),dt=i("li"),io=l("The simulation doesn’t have to be super fast, since you’re allowed to use all data collected since the start of training."),oo=p(),mt=i("li"),so=l("You basically have infinite data because the agent plays more games during training."),ca=p(),H=i("h4"),G=i("a"),gt=i("span"),ro=l("Cons:"),da=p(),Te=i("ul"),yt=i("li"),no=l("It can lead to unnatural behavior, because it’s trying to find the objectively best way to play the game, like a speedrunner."),ma=p(),R=i("h3"),U=i("a"),vt=i("span"),lo=l("Policy Gradient Algorithms"),ga=p(),De=i("p"),ho=l(`Finally, we have policy gradient algorithms.
Like DQNs, these algorithms learn to play video games by playing them over and over again.
Unlike DQNs, instead of trying to predict the value of each action, the model assigns them probabilties.
Initially, you start out with pretty much the same probability of performing any action, but as the model plays the game, it increases the probability of performing highly rewarding actions while doing the opposite for actions that lead to low reward.`),ya=p(),y=i("ul"),wt=i("li"),fo=l("Firouiu (2017) compared an Actor Critic approach against their DQN and found that it tended to perform more realistic behaviors, attacking and evading."),po=p(),bt=i("li"),uo=l("Firouiu (2018) used a recurrent neural network to predict the next frame to deal with input delay."),co=p(),kt=i("li"),mo=l("Project Nabla uses a more efficient Actor Critic variant (PPO) to finetune the model after doing behavior cloning."),va=p(),z=i("h4"),Y=i("a"),Et=i("span"),go=l("Pros:"),wa=p(),v=i("ul"),It=i("li"),yo=l("Like with DQNs, you have basically unlimited data to train on."),vo=p(),_t=i("li"),wo=l("They tend to give you more “realistic” behavior."),bo=p(),At=i("li"),ko=l("Generally, I’ve gotten better results with policy gradient algorithms over DQNs."),ba=p(),J=i("h4"),V=i("a"),Pt=i("span"),Eo=l("Cons:"),ka=p(),je=i("ul"),xt=i("li"),Io=l("You need a really fast environment, since you have to throw out all of your old experience after one iteration of training."),Ea=p(),K=i("h2"),X=i("a"),St=i("span"),_o=l("My Approach"),Ia=p(),Be=i("p"),Ao=l(`I decided to go with PPO, which is a pretty standard policy gradient algorithm.
It looked like DQNs tended to exploit edge cases in the opponent too much during training, making the behavior less realistic.`),_a=p(),Z=i("p"),Po=l("For my feature space, I decided to go with a combination of scalar "),Lt=i("em"),xo=l("and"),So=l(` visual features.
As we’ve seen with the other papers, scalar features alone are actually pretty informative, and they allow you to get away with less intensive architectures.
My rationale was that giving the agent visual features is more “natural”, since it wouldn’t have to memorize things like how close another player has to be for an attack to hit.
I didn’t want to turn this into a computer vision task, though, so instead of pixels, I just displayed the hitboxes and hurtboxes.`),Aa=p(),Qe=i("p"),Lo=l(`Because I didn’t want to iterate on an expensive environment, I wrote a fast, simple, Smash-like fighting game in Bevy.
In the game, you can move left and right, and you also get a jump.
There are four kinds of attacks:`),Pa=p(),d=i("ol"),Nt=i("li"),No=l("A fast, light attack, similar to Smash’s jab attacks,"),To=p(),Tt=i("li"),Do=l("A slow, heavy attack, similar to Smash’s smash attacks,"),jo=p(),Dt=i("li"),Bo=l("A projectile with a fair bit of startup, and"),Qo=p(),jt=i("li"),Mo=l("A grab attack that ignores shields."),xa=p(),Me=i("p"),Fo=l("Speaking of shielding, that’s also something you can do."),Sa=p(),$=i("p"),Wo=l("Aside from being "),Bt=i("em"),Oo=l("much"),qo=l(` faster to run than simulating a Gamecube, being such a simple environment means it’s easier to spot and debug strange behavior.
For instance, agents turning away from each other and firing projectiles off stage could indicate that I accidentally switched their positions.`),La=p(),ee=i("p"),Co=l(`I also wanted agents to generalize to high level play, so instead of having agents play against the in-game AI, I used self play.
I used `),fe=i("a"),Ho=l("the same technique shown in Huggingface’s RL course"),Go=l(`.
At any given time, I had one active agent that was learning to play against a stable of opponents.
The pool of opponents initially consists of a copy of the agent from before training starts, and every couple hundred of steps, I copy the active agent to the pool.
Aside from the network, each opponent also keeps track of its current ELO, which corresponds to its performance compared to every other agent.`),Na=p(),Fe=i("p"),Ro=l(`To update ELO scores, I set up evaluation runs to periodically run during training.
Once I hit a threshold of opponents, I use ELO to figure out which agent to replace, removing the worst performing agents over time.
Thus, as the training process continues, I’d end up with a better and better set of opponents for my active agent to fight against.
This reduces the chance of the agent overfitting against one type of strategy.`),Ta=p(),We=i("p"),Uo=l(`I should note now that I was running all of this on my laptop, which struggles to play Cyberpunk 2077 on medium settings.
With all these moving parts, training got pretty slow.
To speeed things up, I ported over a lot of the hot code to Rust.
While running things in a compiled language immediately sped up the code a bit, the major speedup came from the ability to use all the cores on my machine.
Python’s GIL means writing multithreaded code isn’t easy, but with Rust, I could just spin up as many threads as I needed, while still being able to read from shared memory.`),Da=p(),Oe=i("p"),zo=l("With a couple nights of training, my agents were looking pretty good! They strategically shot projectiles from far away, then inched closer to the opponent to finish them off with a heavy attack."),ja=p(),te=i("img"),Ba=p(),ae=i("p"),Yo=l("Once I was confident that everything was working, I set up training with "),pe=i("a"),Jo=l("libmelee"),Vo=l(`.
After training a couple nights, the agents generally seemed to understand that they were supposed to attack each other, and also that they shouldn’t jump off the stage.`),Qa=p(),ie=i("img"),Ma=p(),oe=i("h2"),se=i("a"),Qt=i("span"),Ko=l("Conclusion"),Fa=p(),re=i("p"),Xo=l(`I’m pretty happy with what I have for now! The agents seem to know what they’re doing, and translating to a real environment feels relatively straightforward, even if it is slow.
If I let this train longer, I’d probably have an agent that could consistently beat me, `),Mt=i("del"),Zo=l("although to be fair this isn’t hard to do"),$o=l("."),Wa=p(),ne=i("p"),es=l(`With that said, I’m switching gears on this project.
The real goal of this project has actually been to integrate `),Ft=i("em"),ts=l("retrieval"),as=l(` into the process, giving agents the ability to use a giant dataset of experiences at during gameplay.
This would reduce the need to memorize combos and strategies.`),Oa=p(),ue=i("p"),is=l(`I’ll make a follow up post that details the state of that effort.
In the meantime, you can see the current state of my code here: `),ce=i("a"),os=l("https://github.com/Boxxfish/smash-rl"),this.h()},l(e){b=o(e,"P",{});var r=s(b);Za=h(r,"One of the coolest applications of machine learning to me is using it to learn to play video games. It’s what got me interested in reinforcement learning in the first place. There’s nothing quite like watching an algorithm slowly go from pressing random buttons, to having almost complete mastery of a game, to the point where it sometimes it’ll do things that surprise even you."),r.forEach(t),Wt=u(e),de=o(e,"P",{});var Ls=s(de);$a=h(Ls,"I’ve been spending some time on the side trying to train an agent to play Smash Bros. In this post, I’ll share what my approach was, and also highlight some of the prior work that’s been done here."),Ls.forEach(t),Ot=u(e),k=o(e,"H2",{id:!0});var ss=s(k);E=o(ss,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ns=s(E);Re=o(Ns,"SPAN",{class:!0}),s(Re).forEach(t),Ns.forEach(t),ei=h(ss,"But Why Smash?"),ss.forEach(t),qt=u(e),me=o(e,"P",{});var Ts=s(me);ti=h(Ts,"For the uninitiated, Super Smash Bros. is a fighting game series where two players attempt to knock each other off of a shared platform. Each character is equipped with a variety of moves to inflict damage (measured as a percentage from 0% to 999%) and send the opponent flying. The more damage a fighter, the harder they fly back."),Ts.forEach(t),Ct=u(e),ge=o(e,"P",{});var Ds=s(ge);ai=h(Ds,"Its large roster of iconic video game characters (where else can you watch Mario beat up Pacman?), alongside its easy to learn yet difficult to master gameplay, has made it one of Nintendo’s bestsellers. The latest game contains 82 different characters, all with their own moveset and properties."),Ds.forEach(t),Ht=u(e),ye=o(e,"P",{});var js=s(ye);ii=h(js,"For instance, Pikachu is a small, nimble fighter who has a variety of fast attacks, but can be easily launched from the stage even at low percentages due to its light body weight. Donkey Kong, on the other hand, is a powerful, heavy fighter with good horizontal recovery, but has a large hitbox and struggles to recover vertically."),js.forEach(t),Gt=u(e),I=o(e,"IMG",{src:!0,alt:!0,class:!0}),Rt=u(e),ve=o(e,"P",{});var Bs=s(ve);oi=h(Bs,"Despite each fighter’s unique qualities, they all obey a common set of rules."),Bs.forEach(t),Ut=u(e),we=o(e,"P",{});var Qs=s(we);si=h(Qs,"All characters have a set of standard attacks that can be executed on the ground (ground attacks) and in the air (aerial attacks) by pressing the “A” button and holding down a direction. If a direction is pressed at the same time the “A” button is pressed, the player can charge up a “smash” attack that deals heavy damage and sends the opponent flying. Each fighter is also equipped with four special moves that can be used by pressing the “B” button and a direction."),Qs.forEach(t),zt=u(e),be=o(e,"P",{});var Ms=s(be);ri=h(Ms,"For defense, holding down the shield button causes a protective shield to appear around the character, which shrinks with more hits and time. While standard and special attacks can’t penetrate through the shield, this leaves the character open to being grabbed."),Ms.forEach(t),Yt=u(e),ke=o(e,"P",{});var Fs=s(ke);ni=h(Fs,"Aside from being fun to play, it’s also an interesting problem for AI! An agent capable of beating top players can’t just master the basic rules of the game, but also know how every character should fight against every other character. In one match up, the best strategy might be to keep the opponent away by shooting at them, then running away when they get too close. In another, it might be best to get up close and unleash a flurry of attacks, forcing the other player to make mistakes."),Fs.forEach(t),Jt=u(e),_=o(e,"P",{});var qa=s(_);li=h(qa,`To best make these decisions, the agent has to take a lot of variables into account: the positions of each player, which state each fighter is in (shielding? recovering? charging up a smash attack?), unique characteristics of the fighter (weight, jump height), how damaged they are, etc.
Even if an agent `),Ue=o(qa,"EM",{});var Ws=s(Ue);hi=h(Ws,"did"),Ws.forEach(t),fi=h(qa," get really good at all of this, it’d still have to master the psychological aspect of the game, trying to get inside its opponent’s head while avoiding the same from happening to it."),qa.forEach(t),Vt=u(e),A=o(e,"P",{});var Ca=s(A);pi=h(Ca,`While there are 5 games in the Smash series, we’ll be focusing on Super Smash Bros. Melee, the game with the most active competitive scene.
Because it’s so widely played, the community has made it really easy to get it up and running on a PC, which makes training `),ze=o(Ca,"EM",{});var Os=s(ze);ui=h(Os,"way"),Os.forEach(t),ci=h(Ca," easier."),Ca.forEach(t),Kt=u(e),P=o(e,"H2",{id:!0});var rs=s(P);x=o(rs,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var qs=s(x);Ye=o(qs,"SPAN",{class:!0}),s(Ye).forEach(t),qs.forEach(t),di=h(rs,"Prior Work"),rs.forEach(t),Xt=u(e),Ee=o(e,"P",{});var Cs=s(Ee);mi=h(Cs,`A couple people have already experimented with using deep learning to train an agent to play Melee.
Here’s a selection of work I was able to dig up:`),Cs.forEach(t),Zt=u(e),c=o(e,"UL",{});var w=s(c);Ie=o(w,"LI",{});var ns=s(Ie);Je=o(ns,"STRONG",{});var Hs=s(Je);gi=h(Hs,"“Beating the World’s Best at Super Smash Bros. Melee with Deep Reinforcement Learning” (2017)"),Hs.forEach(t),yi=h(ns,", a paper by Vlad Firoiu, William F. Whitney, and Josh Tenenbaum,"),ns.forEach(t),vi=u(w),_e=o(w,"LI",{});var ls=s(_e);Ve=o(ls,"STRONG",{});var Gs=s(Ve);wi=h(Gs,"“Learning to Play Super Smash Bros. Melee with Delayed Actions” (2017)"),Gs.forEach(t),bi=h(ls,", a paper by Yash Sharma and Eli Friedman,"),ls.forEach(t),ki=u(w),Ae=o(w,"LI",{});var hs=s(Ae);Ke=o(hs,"STRONG",{});var Rs=s(Ke);Ei=h(Rs,"“At Human Speed: Deep Reinforcement Learning with Action Delay” (2018)"),Rs.forEach(t),Ii=h(hs,", a paper by Vlad Firoiu, Tina Ju, and Josh Tenenbaum,"),hs.forEach(t),_i=u(w),Pe=o(w,"LI",{});var fs=s(Pe);Xe=o(fs,"STRONG",{});var Us=s(Xe);Ai=h(Us,"“Project Nabla” (2022)"),Us.forEach(t),Pi=h(fs,", a blog post by Brian Chen, and"),fs.forEach(t),xi=u(w),xe=o(w,"LI",{});var ps=s(xe);Ze=o(ps,"STRONG",{});var zs=s(Ze);Si=h(zs,"“AI Learns to Play Super Smash Bros” (2022)"),zs.forEach(t),Li=h(ps,", a video by the Youtuber AI Spawn."),ps.forEach(t),w.forEach(t),$t=u(e),m=o(e,"P",{});var qe=s(m);Ni=h(qe,`I’ve broken these down by technique below.
I’ll be giving `),$e=o(qe,"EM",{});var Ys=s($e);Ti=h(Ys,"super"),Ys.forEach(t),Di=h(qe," oversimplified explanations of how each reinforcement learning algorithm works; if you want to learn more, "),he=o(qe,"A",{href:!0,rel:!0});var Js=s(he);ji=h(Js,"this"),Js.forEach(t),Bi=h(qe," is one of the most intuitive sources I’ve found for beginners."),qe.forEach(t),ea=u(e),S=o(e,"H3",{id:!0});var us=s(S);L=o(us,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Vs=s(L);et=o(Vs,"SPAN",{class:!0}),s(et).forEach(t),Vs.forEach(t),Qi=h(us,"Behavior Cloning"),us.forEach(t),ta=u(e),Se=o(e,"P",{});var Ks=s(Se);Mi=h(Ks,"At the most basic, we have behavior cloning. These approaches take recordings of real players and train a network to replicate them."),Ks.forEach(t),aa=u(e),Le=o(e,"P",{});var Xs=s(Le);Fi=h(Xs,`The dataset will typically contain the state of the game as input, and a one hot encoded vector corresponding to the correct action as the output.
Once the network’s trained, you pass data from the game to the network, and take the maximum value of the network.`),Xs.forEach(t),ia=u(e),N=o(e,"UL",{});var Ha=s(N);tt=o(Ha,"LI",{});var Zs=s(tt);Wi=h(Zs,"Project Nabla pretrains a network with scalar features to output one hot encoded actions. The network uses a recurrent GRU layers to take past frames into account."),Zs.forEach(t),Oi=u(Ha),at=o(Ha,"LI",{});var $s=s(at);qi=h($s,"The AI Spawn video used a collection of publically available replays and trained an MLP on it."),$s.forEach(t),Ha.forEach(t),oa=u(e),T=o(e,"H4",{id:!0});var cs=s(T);D=o(cs,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var er=s(D);it=o(er,"SPAN",{class:!0}),s(it).forEach(t),er.forEach(t),Ci=h(cs,"Pros:"),cs.forEach(t),sa=u(e),Ne=o(e,"UL",{});var tr=s(Ne);ot=o(tr,"LI",{});var ar=s(ot);Hi=h(ar,"Easy to understand and implement."),ar.forEach(t),tr.forEach(t),ra=u(e),j=o(e,"H4",{id:!0});var ds=s(j);B=o(ds,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ir=s(B);st=o(ir,"SPAN",{class:!0}),s(st).forEach(t),ir.forEach(t),Gi=h(ds,"Cons:"),ds.forEach(t),na=u(e),Q=o(e,"UL",{});var Ga=s(Q);rt=o(Ga,"LI",{});var or=s(rt);Ri=h(or,"Doesn’t generalize well to unseen game states."),or.forEach(t),Ui=u(Ga),nt=o(Ga,"LI",{});var sr=s(nt);zi=h(sr,"You need an expert to record a bunch of games for you."),sr.forEach(t),Ga.forEach(t),la=u(e),M=o(e,"H3",{id:!0});var ms=s(M);F=o(ms,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var rr=s(F);lt=o(rr,"SPAN",{class:!0}),s(lt).forEach(t),rr.forEach(t),Yi=h(ms,"Deep Q Networks (DQNs)"),ms.forEach(t),ha=u(e),W=o(e,"P",{});var Ra=s(W);Ji=h(Ra,`Next, we have Deep Q Networks.
This is the first algorithm where the AI learns by actually playing the game.
Because there no longer is a “right answer” for each game state, we have to define a reward function for the game, like +1 if you knock the other player off, and -1 if you get knocked off instead.
With Deep Q Networks, you train a network to associate each state with the reward it `),ht=o(Ra,"EM",{});var nr=s(ht);Vi=h(nr,"thinks"),nr.forEach(t),Ki=h(Ra,` it’ll get in the next state, and so on.
Eventually, you get to a point where you can accurately predict how much reward you’ll get at any given game state, which means like with behavior cloning, you can just choose the action that outputs the max value.`),Ra.forEach(t),fa=u(e),g=o(e,"UL",{});var Ce=s(g);ft=o(Ce,"LI",{});var lr=s(ft);Xi=h(lr,"Firouiu (2017) trained DQNs both against the in-game AI and through self play, finding that Q networks could easily exploit edge cases in the opponent. They used an MLP where each player’s position, velocity, action state, etc were passed."),lr.forEach(t),Zi=u(Ce),pt=o(Ce,"LI",{});var hr=s(pt);$i=h(hr,"Sharma trained a DQN with a recurrent architecture against the in-game AI to allow it to use information seen in previous frames."),hr.forEach(t),eo=u(Ce),ut=o(Ce,"LI",{});var fr=s(ut);to=h(fr,"AI Spawn trained a DQN against the in-game AI, also finding that Q networks tend to take advantage of bugs in the in-game AI."),fr.forEach(t),Ce.forEach(t),pa=u(e),O=o(e,"H4",{id:!0});var gs=s(O);q=o(gs,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var pr=s(q);ct=o(pr,"SPAN",{class:!0}),s(ct).forEach(t),pr.forEach(t),ao=h(gs,"Pros:"),gs.forEach(t),ua=u(e),C=o(e,"UL",{});var Ua=s(C);dt=o(Ua,"LI",{});var ur=s(dt);io=h(ur,"The simulation doesn’t have to be super fast, since you’re allowed to use all data collected since the start of training."),ur.forEach(t),oo=u(Ua),mt=o(Ua,"LI",{});var cr=s(mt);so=h(cr,"You basically have infinite data because the agent plays more games during training."),cr.forEach(t),Ua.forEach(t),ca=u(e),H=o(e,"H4",{id:!0});var ys=s(H);G=o(ys,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var dr=s(G);gt=o(dr,"SPAN",{class:!0}),s(gt).forEach(t),dr.forEach(t),ro=h(ys,"Cons:"),ys.forEach(t),da=u(e),Te=o(e,"UL",{});var mr=s(Te);yt=o(mr,"LI",{});var gr=s(yt);no=h(gr,"It can lead to unnatural behavior, because it’s trying to find the objectively best way to play the game, like a speedrunner."),gr.forEach(t),mr.forEach(t),ma=u(e),R=o(e,"H3",{id:!0});var vs=s(R);U=o(vs,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var yr=s(U);vt=o(yr,"SPAN",{class:!0}),s(vt).forEach(t),yr.forEach(t),lo=h(vs,"Policy Gradient Algorithms"),vs.forEach(t),ga=u(e),De=o(e,"P",{});var vr=s(De);ho=h(vr,`Finally, we have policy gradient algorithms.
Like DQNs, these algorithms learn to play video games by playing them over and over again.
Unlike DQNs, instead of trying to predict the value of each action, the model assigns them probabilties.
Initially, you start out with pretty much the same probability of performing any action, but as the model plays the game, it increases the probability of performing highly rewarding actions while doing the opposite for actions that lead to low reward.`),vr.forEach(t),ya=u(e),y=o(e,"UL",{});var He=s(y);wt=o(He,"LI",{});var wr=s(wt);fo=h(wr,"Firouiu (2017) compared an Actor Critic approach against their DQN and found that it tended to perform more realistic behaviors, attacking and evading."),wr.forEach(t),po=u(He),bt=o(He,"LI",{});var br=s(bt);uo=h(br,"Firouiu (2018) used a recurrent neural network to predict the next frame to deal with input delay."),br.forEach(t),co=u(He),kt=o(He,"LI",{});var kr=s(kt);mo=h(kr,"Project Nabla uses a more efficient Actor Critic variant (PPO) to finetune the model after doing behavior cloning."),kr.forEach(t),He.forEach(t),va=u(e),z=o(e,"H4",{id:!0});var ws=s(z);Y=o(ws,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Er=s(Y);Et=o(Er,"SPAN",{class:!0}),s(Et).forEach(t),Er.forEach(t),go=h(ws,"Pros:"),ws.forEach(t),wa=u(e),v=o(e,"UL",{});var Ge=s(v);It=o(Ge,"LI",{});var Ir=s(It);yo=h(Ir,"Like with DQNs, you have basically unlimited data to train on."),Ir.forEach(t),vo=u(Ge),_t=o(Ge,"LI",{});var _r=s(_t);wo=h(_r,"They tend to give you more “realistic” behavior."),_r.forEach(t),bo=u(Ge),At=o(Ge,"LI",{});var Ar=s(At);ko=h(Ar,"Generally, I’ve gotten better results with policy gradient algorithms over DQNs."),Ar.forEach(t),Ge.forEach(t),ba=u(e),J=o(e,"H4",{id:!0});var bs=s(J);V=o(bs,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Pr=s(V);Pt=o(Pr,"SPAN",{class:!0}),s(Pt).forEach(t),Pr.forEach(t),Eo=h(bs,"Cons:"),bs.forEach(t),ka=u(e),je=o(e,"UL",{});var xr=s(je);xt=o(xr,"LI",{});var Sr=s(xt);Io=h(Sr,"You need a really fast environment, since you have to throw out all of your old experience after one iteration of training."),Sr.forEach(t),xr.forEach(t),Ea=u(e),K=o(e,"H2",{id:!0});var ks=s(K);X=o(ks,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Lr=s(X);St=o(Lr,"SPAN",{class:!0}),s(St).forEach(t),Lr.forEach(t),_o=h(ks,"My Approach"),ks.forEach(t),Ia=u(e),Be=o(e,"P",{});var Nr=s(Be);Ao=h(Nr,`I decided to go with PPO, which is a pretty standard policy gradient algorithm.
It looked like DQNs tended to exploit edge cases in the opponent too much during training, making the behavior less realistic.`),Nr.forEach(t),_a=u(e),Z=o(e,"P",{});var za=s(Z);Po=h(za,"For my feature space, I decided to go with a combination of scalar "),Lt=o(za,"EM",{});var Tr=s(Lt);xo=h(Tr,"and"),Tr.forEach(t),So=h(za,` visual features.
As we’ve seen with the other papers, scalar features alone are actually pretty informative, and they allow you to get away with less intensive architectures.
My rationale was that giving the agent visual features is more “natural”, since it wouldn’t have to memorize things like how close another player has to be for an attack to hit.
I didn’t want to turn this into a computer vision task, though, so instead of pixels, I just displayed the hitboxes and hurtboxes.`),za.forEach(t),Aa=u(e),Qe=o(e,"P",{});var Dr=s(Qe);Lo=h(Dr,`Because I didn’t want to iterate on an expensive environment, I wrote a fast, simple, Smash-like fighting game in Bevy.
In the game, you can move left and right, and you also get a jump.
There are four kinds of attacks:`),Dr.forEach(t),Pa=u(e),d=o(e,"OL",{});var le=s(d);Nt=o(le,"LI",{});var jr=s(Nt);No=h(jr,"A fast, light attack, similar to Smash’s jab attacks,"),jr.forEach(t),To=u(le),Tt=o(le,"LI",{});var Br=s(Tt);Do=h(Br,"A slow, heavy attack, similar to Smash’s smash attacks,"),Br.forEach(t),jo=u(le),Dt=o(le,"LI",{});var Qr=s(Dt);Bo=h(Qr,"A projectile with a fair bit of startup, and"),Qr.forEach(t),Qo=u(le),jt=o(le,"LI",{});var Mr=s(jt);Mo=h(Mr,"A grab attack that ignores shields."),Mr.forEach(t),le.forEach(t),xa=u(e),Me=o(e,"P",{});var Fr=s(Me);Fo=h(Fr,"Speaking of shielding, that’s also something you can do."),Fr.forEach(t),Sa=u(e),$=o(e,"P",{});var Ya=s($);Wo=h(Ya,"Aside from being "),Bt=o(Ya,"EM",{});var Wr=s(Bt);Oo=h(Wr,"much"),Wr.forEach(t),qo=h(Ya,` faster to run than simulating a Gamecube, being such a simple environment means it’s easier to spot and debug strange behavior.
For instance, agents turning away from each other and firing projectiles off stage could indicate that I accidentally switched their positions.`),Ya.forEach(t),La=u(e),ee=o(e,"P",{});var Ja=s(ee);Co=h(Ja,`I also wanted agents to generalize to high level play, so instead of having agents play against the in-game AI, I used self play.
I used `),fe=o(Ja,"A",{href:!0,rel:!0});var Or=s(fe);Ho=h(Or,"the same technique shown in Huggingface’s RL course"),Or.forEach(t),Go=h(Ja,`.
At any given time, I had one active agent that was learning to play against a stable of opponents.
The pool of opponents initially consists of a copy of the agent from before training starts, and every couple hundred of steps, I copy the active agent to the pool.
Aside from the network, each opponent also keeps track of its current ELO, which corresponds to its performance compared to every other agent.`),Ja.forEach(t),Na=u(e),Fe=o(e,"P",{});var qr=s(Fe);Ro=h(qr,`To update ELO scores, I set up evaluation runs to periodically run during training.
Once I hit a threshold of opponents, I use ELO to figure out which agent to replace, removing the worst performing agents over time.
Thus, as the training process continues, I’d end up with a better and better set of opponents for my active agent to fight against.
This reduces the chance of the agent overfitting against one type of strategy.`),qr.forEach(t),Ta=u(e),We=o(e,"P",{});var Cr=s(We);Uo=h(Cr,`I should note now that I was running all of this on my laptop, which struggles to play Cyberpunk 2077 on medium settings.
With all these moving parts, training got pretty slow.
To speeed things up, I ported over a lot of the hot code to Rust.
While running things in a compiled language immediately sped up the code a bit, the major speedup came from the ability to use all the cores on my machine.
Python’s GIL means writing multithreaded code isn’t easy, but with Rust, I could just spin up as many threads as I needed, while still being able to read from shared memory.`),Cr.forEach(t),Da=u(e),Oe=o(e,"P",{});var Hr=s(Oe);zo=h(Hr,"With a couple nights of training, my agents were looking pretty good! They strategically shot projectiles from far away, then inched closer to the opponent to finish them off with a heavy attack."),Hr.forEach(t),ja=u(e),te=o(e,"IMG",{src:!0,alt:!0,class:!0}),Ba=u(e),ae=o(e,"P",{});var Va=s(ae);Yo=h(Va,"Once I was confident that everything was working, I set up training with "),pe=o(Va,"A",{href:!0,rel:!0});var Gr=s(pe);Jo=h(Gr,"libmelee"),Gr.forEach(t),Vo=h(Va,`.
After training a couple nights, the agents generally seemed to understand that they were supposed to attack each other, and also that they shouldn’t jump off the stage.`),Va.forEach(t),Qa=u(e),ie=o(e,"IMG",{src:!0,alt:!0,class:!0}),Ma=u(e),oe=o(e,"H2",{id:!0});var Es=s(oe);se=o(Es,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Rr=s(se);Qt=o(Rr,"SPAN",{class:!0}),s(Qt).forEach(t),Rr.forEach(t),Ko=h(Es,"Conclusion"),Es.forEach(t),Fa=u(e),re=o(e,"P",{});var Ka=s(re);Xo=h(Ka,`I’m pretty happy with what I have for now! The agents seem to know what they’re doing, and translating to a real environment feels relatively straightforward, even if it is slow.
If I let this train longer, I’d probably have an agent that could consistently beat me, `),Mt=o(Ka,"DEL",{});var Ur=s(Mt);Zo=h(Ur,"although to be fair this isn’t hard to do"),Ur.forEach(t),$o=h(Ka,"."),Ka.forEach(t),Wa=u(e),ne=o(e,"P",{});var Xa=s(ne);es=h(Xa,`With that said, I’m switching gears on this project.
The real goal of this project has actually been to integrate `),Ft=o(Xa,"EM",{});var zr=s(Ft);ts=h(zr,"retrieval"),zr.forEach(t),as=h(Xa,` into the process, giving agents the ability to use a giant dataset of experiences at during gameplay.
This would reduce the need to memorize combos and strategies.`),Xa.forEach(t),Oa=u(e),ue=o(e,"P",{});var Is=s(ue);is=h(Is,`I’ll make a follow up post that details the state of that effort.
In the meantime, you can see the current state of my code here: `),ce=o(Is,"A",{href:!0,rel:!0});var Yr=s(ce);os=h(Yr,"https://github.com/Boxxfish/smash-rl"),Yr.forEach(t),Is.forEach(t),this.h()},h(){f(Re,"class","icon icon-link"),f(E,"aria-hidden","true"),f(E,"tabindex","-1"),f(E,"href","#but-why-smash"),f(k,"id","but-why-smash"),_s(I.src,Ps="/images/blog/smash-rl-1/dk_vs_pikachu.png")||f(I,"src",Ps),f(I,"alt","dk vs pikachu"),f(I,"class","post-img"),f(Ye,"class","icon icon-link"),f(x,"aria-hidden","true"),f(x,"tabindex","-1"),f(x,"href","#prior-work"),f(P,"id","prior-work"),f(he,"href","https://huggingface.co/learn/deep-rl-course/unit0/introduction"),f(he,"rel","nofollow"),f(et,"class","icon icon-link"),f(L,"aria-hidden","true"),f(L,"tabindex","-1"),f(L,"href","#behavior-cloning"),f(S,"id","behavior-cloning"),f(it,"class","icon icon-link"),f(D,"aria-hidden","true"),f(D,"tabindex","-1"),f(D,"href","#pros"),f(T,"id","pros"),f(st,"class","icon icon-link"),f(B,"aria-hidden","true"),f(B,"tabindex","-1"),f(B,"href","#cons"),f(j,"id","cons"),f(lt,"class","icon icon-link"),f(F,"aria-hidden","true"),f(F,"tabindex","-1"),f(F,"href","#deep-q-networks-dqns"),f(M,"id","deep-q-networks-dqns"),f(ct,"class","icon icon-link"),f(q,"aria-hidden","true"),f(q,"tabindex","-1"),f(q,"href","#pros-1"),f(O,"id","pros-1"),f(gt,"class","icon icon-link"),f(G,"aria-hidden","true"),f(G,"tabindex","-1"),f(G,"href","#cons-1"),f(H,"id","cons-1"),f(vt,"class","icon icon-link"),f(U,"aria-hidden","true"),f(U,"tabindex","-1"),f(U,"href","#policy-gradient-algorithms"),f(R,"id","policy-gradient-algorithms"),f(Et,"class","icon icon-link"),f(Y,"aria-hidden","true"),f(Y,"tabindex","-1"),f(Y,"href","#pros-2"),f(z,"id","pros-2"),f(Pt,"class","icon icon-link"),f(V,"aria-hidden","true"),f(V,"tabindex","-1"),f(V,"href","#cons-2"),f(J,"id","cons-2"),f(St,"class","icon icon-link"),f(X,"aria-hidden","true"),f(X,"tabindex","-1"),f(X,"href","#my-approach"),f(K,"id","my-approach"),f(fe,"href","https://huggingface.co/learn/deep-rl-course/unit7/self-play?fw=pt"),f(fe,"rel","nofollow"),_s(te.src,xs="/images/smash_rl.gif")||f(te,"src",xs),f(te,"alt","smash rl"),f(te,"class","post-img"),f(pe,"href","https://github.com/altf4/libmelee"),f(pe,"rel","nofollow"),_s(ie.src,Ss="/images/blog/smash_rl_1.gif")||f(ie,"src",Ss),f(ie,"alt","melee playing"),f(ie,"class","post-img"),f(Qt,"class","icon icon-link"),f(se,"aria-hidden","true"),f(se,"tabindex","-1"),f(se,"href","#conclusion"),f(oe,"id","conclusion"),f(ce,"href","https://github.com/Boxxfish/smash-rl"),f(ce,"rel","nofollow")},m(e,r){n(e,b,r),a(b,Za),n(e,Wt,r),n(e,de,r),a(de,$a),n(e,Ot,r),n(e,k,r),a(k,E),a(E,Re),a(k,ei),n(e,qt,r),n(e,me,r),a(me,ti),n(e,Ct,r),n(e,ge,r),a(ge,ai),n(e,Ht,r),n(e,ye,r),a(ye,ii),n(e,Gt,r),n(e,I,r),n(e,Rt,r),n(e,ve,r),a(ve,oi),n(e,Ut,r),n(e,we,r),a(we,si),n(e,zt,r),n(e,be,r),a(be,ri),n(e,Yt,r),n(e,ke,r),a(ke,ni),n(e,Jt,r),n(e,_,r),a(_,li),a(_,Ue),a(Ue,hi),a(_,fi),n(e,Vt,r),n(e,A,r),a(A,pi),a(A,ze),a(ze,ui),a(A,ci),n(e,Kt,r),n(e,P,r),a(P,x),a(x,Ye),a(P,di),n(e,Xt,r),n(e,Ee,r),a(Ee,mi),n(e,Zt,r),n(e,c,r),a(c,Ie),a(Ie,Je),a(Je,gi),a(Ie,yi),a(c,vi),a(c,_e),a(_e,Ve),a(Ve,wi),a(_e,bi),a(c,ki),a(c,Ae),a(Ae,Ke),a(Ke,Ei),a(Ae,Ii),a(c,_i),a(c,Pe),a(Pe,Xe),a(Xe,Ai),a(Pe,Pi),a(c,xi),a(c,xe),a(xe,Ze),a(Ze,Si),a(xe,Li),n(e,$t,r),n(e,m,r),a(m,Ni),a(m,$e),a($e,Ti),a(m,Di),a(m,he),a(he,ji),a(m,Bi),n(e,ea,r),n(e,S,r),a(S,L),a(L,et),a(S,Qi),n(e,ta,r),n(e,Se,r),a(Se,Mi),n(e,aa,r),n(e,Le,r),a(Le,Fi),n(e,ia,r),n(e,N,r),a(N,tt),a(tt,Wi),a(N,Oi),a(N,at),a(at,qi),n(e,oa,r),n(e,T,r),a(T,D),a(D,it),a(T,Ci),n(e,sa,r),n(e,Ne,r),a(Ne,ot),a(ot,Hi),n(e,ra,r),n(e,j,r),a(j,B),a(B,st),a(j,Gi),n(e,na,r),n(e,Q,r),a(Q,rt),a(rt,Ri),a(Q,Ui),a(Q,nt),a(nt,zi),n(e,la,r),n(e,M,r),a(M,F),a(F,lt),a(M,Yi),n(e,ha,r),n(e,W,r),a(W,Ji),a(W,ht),a(ht,Vi),a(W,Ki),n(e,fa,r),n(e,g,r),a(g,ft),a(ft,Xi),a(g,Zi),a(g,pt),a(pt,$i),a(g,eo),a(g,ut),a(ut,to),n(e,pa,r),n(e,O,r),a(O,q),a(q,ct),a(O,ao),n(e,ua,r),n(e,C,r),a(C,dt),a(dt,io),a(C,oo),a(C,mt),a(mt,so),n(e,ca,r),n(e,H,r),a(H,G),a(G,gt),a(H,ro),n(e,da,r),n(e,Te,r),a(Te,yt),a(yt,no),n(e,ma,r),n(e,R,r),a(R,U),a(U,vt),a(R,lo),n(e,ga,r),n(e,De,r),a(De,ho),n(e,ya,r),n(e,y,r),a(y,wt),a(wt,fo),a(y,po),a(y,bt),a(bt,uo),a(y,co),a(y,kt),a(kt,mo),n(e,va,r),n(e,z,r),a(z,Y),a(Y,Et),a(z,go),n(e,wa,r),n(e,v,r),a(v,It),a(It,yo),a(v,vo),a(v,_t),a(_t,wo),a(v,bo),a(v,At),a(At,ko),n(e,ba,r),n(e,J,r),a(J,V),a(V,Pt),a(J,Eo),n(e,ka,r),n(e,je,r),a(je,xt),a(xt,Io),n(e,Ea,r),n(e,K,r),a(K,X),a(X,St),a(K,_o),n(e,Ia,r),n(e,Be,r),a(Be,Ao),n(e,_a,r),n(e,Z,r),a(Z,Po),a(Z,Lt),a(Lt,xo),a(Z,So),n(e,Aa,r),n(e,Qe,r),a(Qe,Lo),n(e,Pa,r),n(e,d,r),a(d,Nt),a(Nt,No),a(d,To),a(d,Tt),a(Tt,Do),a(d,jo),a(d,Dt),a(Dt,Bo),a(d,Qo),a(d,jt),a(jt,Mo),n(e,xa,r),n(e,Me,r),a(Me,Fo),n(e,Sa,r),n(e,$,r),a($,Wo),a($,Bt),a(Bt,Oo),a($,qo),n(e,La,r),n(e,ee,r),a(ee,Co),a(ee,fe),a(fe,Ho),a(ee,Go),n(e,Na,r),n(e,Fe,r),a(Fe,Ro),n(e,Ta,r),n(e,We,r),a(We,Uo),n(e,Da,r),n(e,Oe,r),a(Oe,zo),n(e,ja,r),n(e,te,r),n(e,Ba,r),n(e,ae,r),a(ae,Yo),a(ae,pe),a(pe,Jo),a(ae,Vo),n(e,Qa,r),n(e,ie,r),n(e,Ma,r),n(e,oe,r),a(oe,se),a(se,Qt),a(oe,Ko),n(e,Fa,r),n(e,re,r),a(re,Xo),a(re,Mt),a(Mt,Zo),a(re,$o),n(e,Wa,r),n(e,ne,r),a(ne,es),a(ne,Ft),a(Ft,ts),a(ne,as),n(e,Oa,r),n(e,ue,r),a(ue,is),a(ue,ce),a(ce,os)},p:As,i:As,o:As,d(e){e&&t(b),e&&t(Wt),e&&t(de),e&&t(Ot),e&&t(k),e&&t(qt),e&&t(me),e&&t(Ct),e&&t(ge),e&&t(Ht),e&&t(ye),e&&t(Gt),e&&t(I),e&&t(Rt),e&&t(ve),e&&t(Ut),e&&t(we),e&&t(zt),e&&t(be),e&&t(Yt),e&&t(ke),e&&t(Jt),e&&t(_),e&&t(Vt),e&&t(A),e&&t(Kt),e&&t(P),e&&t(Xt),e&&t(Ee),e&&t(Zt),e&&t(c),e&&t($t),e&&t(m),e&&t(ea),e&&t(S),e&&t(ta),e&&t(Se),e&&t(aa),e&&t(Le),e&&t(ia),e&&t(N),e&&t(oa),e&&t(T),e&&t(sa),e&&t(Ne),e&&t(ra),e&&t(j),e&&t(na),e&&t(Q),e&&t(la),e&&t(M),e&&t(ha),e&&t(W),e&&t(fa),e&&t(g),e&&t(pa),e&&t(O),e&&t(ua),e&&t(C),e&&t(ca),e&&t(H),e&&t(da),e&&t(Te),e&&t(ma),e&&t(R),e&&t(ga),e&&t(De),e&&t(ya),e&&t(y),e&&t(va),e&&t(z),e&&t(wa),e&&t(v),e&&t(ba),e&&t(J),e&&t(ka),e&&t(je),e&&t(Ea),e&&t(K),e&&t(Ia),e&&t(Be),e&&t(_a),e&&t(Z),e&&t(Aa),e&&t(Qe),e&&t(Pa),e&&t(d),e&&t(xa),e&&t(Me),e&&t(Sa),e&&t($),e&&t(La),e&&t(ee),e&&t(Na),e&&t(Fe),e&&t(Ta),e&&t(We),e&&t(Da),e&&t(Oe),e&&t(ja),e&&t(te),e&&t(Ba),e&&t(ae),e&&t(Qa),e&&t(ie),e&&t(Ma),e&&t(oe),e&&t(Fa),e&&t(re),e&&t(Wa),e&&t(ne),e&&t(Oa),e&&t(ue)}}}const en={title:"Playing Smash Bros. with Neural Networks",date:"2024-02-11",updated:"2024-02-11",categories:["projects","reinforcement-learning","smash-bros"],coverImage:"/images/blog/smash_rl_1.gif",coverWidth:16,coverHeight:9,excerpt:"Automating the fun part of video games."};class tn extends Vr{constructor(b){super(),Kr(this,b,null,Zr,Xr,{})}}export{tn as default,en as metadata};
